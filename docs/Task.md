# Техническое задание: RAG-система для юридической компании

## Введение

**В чем идея**: юристам надо искать подтверждение в законах и судебной практике и долго сидеть на "консультант плюс" и других сайтах с документами, выискивая нужные данные долго.
Современные методы позволяют векторизовать тексты с помощью эмбеддеров и загрузить это в векторную базу данных, после чего можно легко использовать семантический поиск.
Нужно написать приложение, которое по обращению на естественном языке выдает юридическую консультацию с указанием источников.

## Требования

#### Основной функционал приложения

- Отправка текстовых запросов на естественном языке
- Получение ответов с юридической информацией, сгенерированные нейросетью
- Отображение источников информации (ссылки на законы/документы)
- Выбор активной коллекции для поиска
- Добавление новых данных в коллекцию, создание новых коллекций
- Платная подписка после 10 пробных запросов (нужно написать платежный сервис простой)

#### Работа с базой данных
- Возможность создания новой коллекции документов
- Загрузка пользовательских документов в выбранную коллекцию
- Поиск по базе с возвратом топ-k близких текстов
- Просмотр списка доступных коллекций

#### Требования по качеству
- Создать тестовый датасет, по которому подбирать компоненты моделей и их параметры
- Выдача топ-5 релевантных законов валидируется по метрике hit@5 (равна 1, если есть хотя бы 1 нужный документ и 0 иначе), которая усредняется для всех запросов пользователя
- Ваша модель должна выдавать качество больше 50% (больше половины запросов содержат хотя бы один 1 нужный документ в ответе)

Тестовый датасет должен быть в формате двух столбцов: query, document_ids

Пример содержания строки в датасете в формате json:

```json
{
  "query": "Что будет если я убью человека?",
  "document_ids": [1, 2, 3, 4, 5]
}
```

## Требования к архитектуре системы

- Использование DDD + Dependency Injection
- Разделение приложения на FastAPI и телеграм бота в отдельные контейнеры
- Все асинхронно
- Стараться следовать SOLID

## Требования к системным сущностям (примерные)

#### Пользователь (User)
```sql
Users:
- user_id (UUID, PK)
- telegram_id (String)
- created_at (DateTime)
- role (String) (юзер или админ)
```

#### Коллекция документов (DocumentCollection)
```sql
Collections:
- collection_id (UUID, PK)
- name (String)
- description (Text)
- owner_id (UUID, FK)
- is_public (Boolean)
- created_at (DateTime)
```

#### Документ (Document)
```sql
Documents:
- document_id (UUID, PK)
- collection_id (UUID, FK)
- title (String)
- content (Text)
- metadata (JSON)
- vector_embedding (Vector)
- created_at (DateTime)
```

#### Векторное представление (VectorEmbedding)
```sql
Embeddings:
- embedding_id (UUID, PK)
- document_id (UUID, FK)
- embedding (Vector)
- model_version (String)
- created_at (DateTime)
```

#### Диалог (Conversation)
```sql
Conversations:
- conversation_id (UUID, PK)
- user_id (UUID, FK)
- collection_id (UUID, FK)
- created_at (DateTime)
- updated_at (DateTime)
```

#### Сообщение (Message)
```sql
Messages:
- message_id (UUID, PK)
- conversation_id (UUID, FK)
- content (Text)
- role (String)
- sources (JSON)
- created_at (DateTime)
```

## Из чего состоит ваша RAG система

1) Векторная база данных: хранилище коллекций документов
2) Индексатор: программа, которая принимает на вход текст, как-то его предобрабатывает, векторизует и записывает в базу.
3) Поисковик: программа, которая принимает на вход запрос пользователя, как-то его предобрабатывает, векторизует и ищет похожие документы.
4) Реранкер: программа, которая смотрит на то, что выдал поисковик и формирует итоговый ответ из топ-5 лучших документов, используя реранк подход.
5) Генератор: программа, которая принимает на вход промпт и возвращает ответ LLM
6) Админ панель: администрирование данных компании в нашей системе (добавление/удаление)
7) Бот: программа, через которую пользователь общается с системой

## Требование по стеку 

- **Бэкенд**: Python, FastAPI, dishka, sqlalchemy / mongo (выберите сами бд), langchain, torch, transformers
- **Векторная БД**: Chroma/Qdrant (но вообще любые)
- **Эмбеддинг модели**: любые (лучше всего взять FRIDA)
- **Реранк модели**: любые
- **LLM**: любые, лучше использовать апи
- **Бот**: aiogram
- **Кэширование**: Redis (можно для близких запросов выдавать из кэша ответ)

## Советы

Пишите компоненты программы изолированно, так как в процессе перебора вариантов эмбеддеров, 
перебора параметров предобработки текста и других предобработок вам придется постоянно менять код,
а значит ваши изменения должны не менять сильно логику других компонентов кода.

Используйте DTO для передачи данных между компонентами.

Используйте интерфейсы для создания контрактов взаимодействия компонентов.